Git 是一款分布式的代码版本控制工具

你可以将他想象成可以记录你写的代码的历史版本的旮旯给木的存档点，可以详细的记录代码更变的细节以及存档，可以做到随意切换到不同版本的分支。

## 快速上手
阅读这一篇指南：
https://missing-semester-cn.github.io/2020/version-control/


![[Pasted image 20260126161311.png]]


## 情景1：
我们正在写一项作业，开发工作已经基本完成，试运行也能够得到90分。此时我们希望进一步精进代码，使得分数达到95分以上；但是经过一通修改以后，发现程序再也运行不起来了。这时候距离 ddl 只有1小时，我们决定摆烂，提交能够得到90分的代码。然后我们根据记忆改回原来的代码的时候，发现我们再也想不起来旧代码是怎么写的了！这无疑是令人极为懊恼的。

## 情景2：
假设我们正在开发一个大型项目，项目中有很多人参与开发。如果使用传统的方式来分发代码，那么每个人都要手动下载代码，修改代码，然后再上传代码。这时候就会出现很多问题，例如代码冲突、版本不一致等。那这就需要专门的一个人或者几个人来管理代码的版本和分发，但是这样就会显著增加工作量和复杂度。

为了解决以上两个问题，我们引入了vcs（版本控制系统）

vcs分为集中式版本控制系统（CVCS，也叫中心化的）和分布式版本控制系统（DVCS，也叫去中心化的）都是我们以及设计的版本控制系统

这是cvcs
![[Pasted image 20260127122203.png]]


实际上cvcs以及解决了大部分问题了，而他最大的问题在于必须联网才能工作，如果在局域网或者网速比较快的地方可能还好，但是如果是网速慢很容易发生问题。


分布式管理系统则很好的解决了这个问题。
分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。
多个人的协作，分布式管理系统的安全性更高，比方说你在自己电脑上改了文件A，你的团队成员也在他的电脑上改了文件A，这时，你们俩之间只需把==各自的修改==推送给对方，就可以互相看到对方的修改了。

![[Pasted image 20260127134833.png]]


## **历史趣事**
> 2002 年以前，Linux 内核开发完全依赖于 Linus 一个人手工检查并合并全世界发来的补丁，这样工作量非常大。于是，Linus 的一个朋友介绍了 BitMover 公司开发的商业 VCS 软件 BitKeeper 免费授权给 Linux 开发团队使用。此举招致了 FSF 的 RMS 等人的批评，认为在自由软件开发中使用非自由软件是“道德上有污点”的行为。但是作为实用主义者的 Linus 并不在意这些事情，BitKeeper 作为去中心化的 VCS，满足了 Linus 的需求。然而好景不长，有 Linux 内核开发者逆向了 BitKeeper 的协议，致使 BitMover 公司在 2005 年决定收回其授权。Git 就是在这种条件下诞生的，据说第一版 Git 是 Linus 利用 1 周休假时间完成的。随着Linux的广泛应用，Git也逐渐成为了最流行的去中心化版本控制系统，也是目前最流行的版本控制系统。


##  GIT
git有三个目录共同完成版本控制：
我们称之为：工作区、暂存区、版本库



![[Pasted image 20260127140228.png]]

暂存区是一个隐藏的`.git`文件夹
版本库是一个隐藏的文件夹`.git/objects`

工作区是我们平时使用的目录
暂存区是Git用来存储修改的地方
版本库是Git用来存储所有版本信息的地方

版本库是 Git 的“大脑”，存储着所有`历史快照`（Objects 目录）和`分支引用`（Refs 目录）

我们现在来基于上面的图进行讲解：

现在，Git中有一个版本为`X`的节点，包括文件`A`和文件`B`两个文件。这些文件存储在==版本库==中。此时，工作区为空，暂存区为空，指针指向`X`


![[Pasted image 20260127160325.png]]




我现在希望对它们进行修改，这个修改遵循以下过程：

1. 我拿出了这些文件，并且对文件`A`进行修改。此时，工作区有`AB`两个文件，但是暂存区依然是空的。我们的任何修改都不会被暂存区记录，Git也不会知道我对这些文件进行了修改。

![[Pasted image 20260127160145.png]]



2. 我觉得修改差不多了，现在把A放进暂存区。现在Git知道我对`A`进行了一些修改了。

![[Pasted image 20260127160449.png]]

3. 我又对B进行了类似的修改，此时B也进暂存区了。

![[Pasted image 20260127160549.png]]

4. 我觉得修改差不多了。我认为我应该永久保存目前的状态，于是就把暂存区提交(commit)到版本库。此时版本库多了一个Y节点，指针也指向Y节点，有修改过的AB两个文件。此时，暂存区又清空了，而工作区和版本库的Y版本一致。
![[Pasted image 20260127162305.png]]



---
##  Git 的数据模型

从上述的讲解可知进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。

## 快照

>Git 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在 Git 的术语里，文件被称作 Blob 对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：
```
<root> (tree)
|
+- foo (tree)
|  |
|  + bar.txt (blob, contents = "hello world")
|
+- baz.txt (blob, contents = "git is wonderful")
```
>这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个 blob 对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。

### 解释:

Git 内部是如何通过**三级模型**来存储你的文件

1. **Blob**（数据对象）：==纯净的内容==

- **理解**：Blob (Binary Large Object)只存储文件的**具体内容**，不存文件名、时间或权限。
- **例子**：就像一张写满字的纸，这张纸本身不叫“日记.txt”，它只是一段内容。如果两个文件的内容完全一样，Git 在后台只会存一个 Blob 以节省空间（即**去重机制**）。

2. Tree（树对象）：文件夹的清单

- **理解**：**Tree** 就像一张“清单”或“==目录索引==”。
- **映射关系**：清单里记录了这一层级下有什么东西。它把**名字**（如 `bar.txt`）和对应的 **Blob 内容**关联起来，或者关联到另一个 **Tree**（代表子目录）。
- **例子**：就像一个文件夹里贴了一张表，上面写着：“这里面有个文件叫 A，内容在编号为 001 的纸上；还有个子文件夹叫 B，它的详细清单在编号为 002 的表里”。


## 历史记录建模：关联快照
版本控制系统和快照有什么关系呢？==线性历史记录==是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过出于种种原因，Git 并没有采用这样的模型。

在 Git 中，历史记录是一个由快照组成的有向无环图。有向无环图，听上去似乎是什么高大上的数学名词。不过不要怕，你只需要知道这代表 Git 中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。注意，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。

在 Git 中，这些快照被称为“提交”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：
```
o <-- o <-- o <-- o
            ^
             \
              --- o <-- o
```

箭头指向了当前提交的父辈（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：
```
o <-- o <-- o <-- o <----  o 
            ^            /
             \          v
              --- o <-- o
```


## 修改

Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。


## 数据模型及其伪代码表示

以伪代码的形式来学习 Git 的数据模型，可能更加清晰：

```
// 文件就是一组数据
type blob = array<byte>

// 一个包含文件和目录的目录
type tree = map<string, tree | blob>

// 每个提交都包含一个父辈，元数据和顶层树
type commit = struct {
    parents: array<commit>
    author: string
    message: string
    snapshot: tree
}
```

这是一种简洁的历史模型。